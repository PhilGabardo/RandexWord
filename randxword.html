
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
<meta name="googlebot" content="noindex, nofollow">
<script type="text/javascript" src="dict2.js"></script> 
<script type="text/javascript" src="word2.js"></script> 
<script type='text/javascript' src=' http://code.jquery.com/jquery-1.11.0.js'></script>
<style type="text/css">
#puzzle {
	width:100%;
margin: 0;
padding: 10px;
border: 1px solid black;
}


.square{
width:30px;
height:30px;
margin: 0;
padding: 0;
	 border-collapse: collapse;
position: relative;
}


.empty{
	background-color:black;
border: 1px solid black;
}

.letter{
border: 1px solid black;
cursor: pointer;
	text-align: center;
	vertical-align: middle;
	line-height: 30px;
color: transparent;
       text-shadow: 0 0 0 gray;
       text-align: center;


       &:focus {
outline: none;
       }
}

.letter:hover{
border: 1px solid blue;
}

#puzzle_container{
float: left;
width:50%
	      height: 50%;
}

#hints_container{
float: left;
width:50%
	      height: 50%;
      margin-left: 25px;
}

#buttons_container{
clear: both;
       padding-top: 20px;
       margin-left: 50px;
}

.active{
}

.question_number{
position: absolute;
	  font-size: 12px;
color: grey;
left: 3px;
top: 3px;
}

td{
position:relative;
}
</style>
<title></title>
<script type='text/javascript'>


// All clues
var clues = [];

// All answers
var answers = [];

// Index grid
var grid =  [];

// Character grid
var charGrid = [];


// Initialize empty grids
for (var i = 0; i < 15; i++){
	var row = [];
	var charRow = [];
	for (var j = 0; j < 15; j++){
		row.push(0);
		charRow.push(0);
	}
	charGrid.push(charRow);
	grid.push(row);
}


// Generate equal likelihood of first clue being horizontal
function isHorizontal(){
	var myNum = Math.floor(Math.random() * 2);
	if (myNum == 0){
		return true;
	}
	else{
		return false;
	}
}

// Get random clue from dictionary (relationship of answers to clues is one to many)
function getClue(dict, myWord){
	var clues = dict[myWord];
	return clues[Math.floor(Math.random() * clues.length)];
}

// Shuffle an array
function shuffle(array) {
	if (array == undefined) return array
		var currentIndex = array.length, temporaryValue, randomIndex;

	// While there remain elements to shuffle...
	while (0 !== currentIndex) {

		// Pick a remaining element...
		randomIndex = Math.floor(Math.random() * currentIndex);
		currentIndex -= 1;

		// And swap it with the current element.
		temporaryValue = array[currentIndex];
		array[currentIndex] = array[randomIndex];
		array[randomIndex] = temporaryValue;
	}

	return array;
}

// Find the next word, and its position, in the crossword
function findNextWord(grid, stack, wordFinder){

	// Assume the result is empty
	var result = {word: undefined, x: undefined, y:undefined, horizontal: undefined};
	if (stack.length == 0){
		return result;
	}

	// Word to build on
	var indices = stack[stack.length-1];
	var myX = indices[0];
	var myY = indices[1];
	var wordLength = indices[2];
	var horizontal = indices[3];


	// Words that could possibly work
	var potentialWords = [];


	// Possible new starting indices of new word
	var newX;
	var newY;



	// How many possible intersect points are there?
	intersectIndices = [];
	for (var i = 0; i < wordLength; i++){
		intersectIndices.push(i);
	}
	intersectIndices = shuffle(intersectIndices);

	// Try all possible intersections
	for (var i = 0; i < intersectIndices.length; i++){


		// How much slack do we have above or left of the word?
		var slack = [0];

		var count = 1;
		if (horizontal) {
			newY = myY + intersectIndices[i];


			if (myX > 0 && grid[myX - 1][newY] != 0){
				continue;
			}
			if (myX < grid.length - 1 && grid[myX + 1][newY] != 0){
				continue;
			}

			var xRange = myX;
			while (xRange > 0 && (xRange == myX || grid[xRange - 1][newY] == 0)){
				xRange -= 1;
				slack.push(count);
				count += 1;
			}
		}
		else {
			newX = myX + intersectIndices[i];


			if (myY > 0 && grid[newX][myY - 1] != 0){
				continue;
			}
			if (myY < grid.length - 1 && grid[newX][myY + 1] != 0){
				continue;
			}

			var yRange = myY;
			while (yRange > 0 && (yRange == myY || grid[newX][yRange - 1] == 0)){
				yRange -= 1;
				slack.push(count);
				count += 1;
			}

		}

		slack = shuffle(slack);


		// Try all possible slacks
		for (var j = 0; j < slack.length; j++){
			if (horizontal) {
				newX = myX - slack[j];


				if (newX > 0 && newX < grid.length - 1 && grid[newX - 1][newY] != 0){
					continue;
				}



				if (slack[j] == 0){
					if (newX > 0 && grid[newX - 1][newY] != 0){
						continue;
					}
					if (newX < grid.length - 1 && grid[newX + 1][newY] != 0){
						continue;
					}
				}
				else {
					if (newX > 0 && grid[newX - 1][newY] != 0){
						continue;
					}
				}



				potentialWords = wordFinder[myX - newX][grid[myX][newY]];
				potentialWords = shuffle(potentialWords);
			}
			else {
				newY = myY - slack[j];


				if (newY > 0 && newY < grid.length - 1 && grid[newX][newY - 1] != 0){
					continue;
				}


				if (slack[j] == 0){
					if (newY > 0 && grid[newX][newY - 1] != 0){
						continue;
					}
					if (newY < grid.length - 1 && grid[newX][newY + 1] != 0){
						continue;
					}
				}
				else {
					if (newY > 0 && grid[newX][newY - 1] != 0){
						continue;
					}
				}


				potentialWords = wordFinder[myY - newY][grid[newX][myY]];
				potentialWords = shuffle(potentialWords);

			}

			if (potentialWords == undefined){
				continue;
			}

			// Try all possible words
			for (var k = 0; k < potentialWords.length; k++){
				var newWord = potentialWords[k];

				if (newWord in answers){
					continue;
				}

				var feasible = true;

				// Check if word works. There are several constraints to check...
				if (horizontal){
					for (var l = 0; l < newWord.length; l++){

						// Can word fit in grid?
						if (newX + l >= grid.length){
							feasible = false;
							break;
						}
						else if(newX + newWord.length < grid.length && grid[newX + newWord.length][newY] != 0){
							feasible = false;
							break;
						}
						// Will the word match up with all existing characters in the grid?
						else if (grid[newX + l][newY] != 0 && grid[newX + l][newY] != newWord.charAt(l)){
							feasible = false;
							break;
						}
						// Is the word adjacent to another word?
						else if (newY > 0 && newY < grid.length - 1 && grid[newX +l][newY - 1] != 0 && grid[newX +l][newY + 1] == 0){
							feasible = false;
							break;
						}
						// Is the word adjacent to another word?
						else if (newY > 0 && newY < grid.length - 1 && grid[newX +l][newY - 1] == 0 && grid[newX +l][newY + 1] != 0){
							feasible = false;
							break;
						}

						// Is the word adjacent to another word?
						else if (l != slack[j] && newY > 0 && newY < grid.length - 1 && grid[newX +l][newY - 1] != 0 && grid[newX +l][newY + 1] != 0){
							feasible = false;
							break;
						}

						// Is the word adjacent to another word?
						else if (newY == 1 && grid[newX +l][newY - 1] != 0){
							feasible = false;
						}
						// Is the word adjacent to another word?
						else if (newY == grid.length - 2 && grid[newX +l][newY + 1] != 0){
							feasible = false;
						}
						// Is the word between two words?
						else if (newY > 0 && newY < grid.length - 1 && grid[newX +l][newY - 1] != 0 && grid[newX +l][newY + 1] != 0){
							if (newX + l < newWord.length - 1 && grid[newX +l + 1][newY - 1] != 0 && grid[newX + l + 1][newY + 1] != 0){
								feasible = false;
								break;
							}
						}
					}
				}
				else {
					for (var l = 0; l < newWord.length; l++){
						// Can the word fit in grid?
						if (newY + l >= grid.length){
							feasible = false;
							break;
						}
						else if (newY + newWord.length < grid.length && grid[newX][newY + newWord.length] != 0){
							feasible = false;
							break;
						}
						// Will the word match up with all existing characters in the grid?
						else if (grid[newX][newY + l] != 0 && grid[newX][newY + l] != newWord.charAt(l)){
							feasible = false;	
							break;
						}
						// Is the word adjacent to another word?
						else if (newX > 0 && newX < grid.length - 1 && grid[newX - 1][newY + l] != 0 && grid[newX + 1][newY + l] == 0){
							feasible = false;
							break;
						}
						// Is the word adjacent to another word?
						else if (newX > 0 && newX < grid.length - 1 && grid[newX - 1][newY + l] == 0 && grid[newX + 1][newY + l] != 0){
							feasible = false;
							break;
						}

						else if (l != slack[j] && newX > 0 && newX < grid.length - 1 && grid[newX - 1][newY + l] != 0 && grid[newX + 1][newY + l] != 0){
							feasible = false;
							break
						}


						// Is the word adjacent to another word?
						else if (newX == 1  && grid[newX - 1][newY + l] != 0 ){
							feasible = false;
						}
						// Is the word adjacent to another word?
						else if (newX == grid.length - 2 && grid[newX + 1][newY + l] != 0){
							feasible = false;
						}
						// Is the word between two words?
						else if (newX > 0 && newX < grid.length - 1 && grid[newX - 1][newY + l] != 0 && grid[newX + 1][newY + l] != 0){
							if (newY + l < newWord.length - 1 && grid[newX - 1 + 1][newY + l] != 0 && grid[newX + 1][newY + l + 1] != 0) {
								feasible = false;
								break;
							}
						}


					}
				}

				// If word words, return it!
				if (feasible && newWord.length > 1 && !(newWord in answers)) {
					result.word = newWord;
					result.x = newX;
					result.y = newY;
					result.horizontal = horizontal;
					return result;
				}
			}
		}
	}

	// Pop word from stack and try again.
	stack.pop();
	return findNextWord(grid, stack, wordFinder);
}


function generateCW(words, dict){
	var wordCount = 1;
	var found = true;
	var myX = 0;
	var myY = Math.floor(Math.random() * grid.length);

	// Dictionary to find words that have letters at specific indices. 
	var wordFinder = new Array();

	// Stack to keep track of words
	var locationStack = [];

	for (var i = 0; i < words.length; i++){
		var word = words[i];

		for (var j = 0; j < word.length; j++){
			if (!(j in wordFinder)){
				wordFinder[j] = {};
			}
			if (!(word.charAt(j) in wordFinder[j])){
				wordFinder[j][word.charAt(j)] = [];
			}
			wordFinder[j][word.charAt(j)].push(word);
		}
	}


	var horizontal = isHorizontal();

	// Generate a starting word
	var myWordIndex = Math.floor(Math.random() * words.length);
	var myWord = words[myWordIndex];
	var myClue = getClue(dict, myWord);

	// Populate lists with starting word
	answers.push(myWord);
	clues.push(myClue);
	locationStack.push([myX, myY, myWord.length, horizontal]);


	while (found){


		/*
		   console.log("COUNT = " + answers.length);
		   console.log("WORD = " + myWord);
		   console.log("X = " + myX);
		   console.log("Y = " + myY);
		   console.log("HORIZONTAL = " + horizontal);*/

		// Add word to grids
		if (horizontal){
			for (var i = 0; i < myWord.length; i++){
				if (grid[myX][myY + i] == 0){
					grid[myX][myY + i] = "" + wordCount;
				}
				else{
					grid[myX][myY + i] = grid[myX][myY + i] + "," + wordCount;
				}
				charGrid[myX][myY + i] = myWord.charAt(i);
			}
		}
		else {
			for (var i = 0; i < myWord.length; i++){
				if (grid[myX + i][myY] == 0) {
					grid[myX + i][myY] = wordCount;
				}
				else {
					grid[myX + i][myY] = grid[myX + i][myY] + "," + wordCount;
				}
				charGrid[myX + i][myY] = myWord.charAt(i);
			}
		}


		// Try to find next word
		var update = findNextWord(charGrid, locationStack, wordFinder);
		myWord = update.word;
		myX = update.x;
		myY = update.y;
		horizontal = update.horizontal;

		// If word can't be found, or too many answers, then stop
		if (myWord == undefined){
			found = false;
		}

		// Update lists
		else{
			myClue = getClue(dict, myWord);	
			answers.push(myWord);
			clues.push(myClue);
			locationStack.push([myX, myY, myWord.length, !horizontal]);		
		}

		// Change horizontal and increment the count!
		horizontal = !horizontal;
		wordCount += 1;
	}	

}

$(window).load(function(){

		var constraintDict = {};

		generateCW(myWords, myDict);

		//Draw grid

		$.each(grid,function(i){
			var row = $('<tr></tr>');
			$.each(this,function(j){
				if(this == 0){
					$(row).append('<td class="square empty"></td>');  
				}
				else{
					var question_number = String(grid[i][j]).split(",");

					var starting_number = '';
					var question_number_span = '';

					for(var k = 0;k < question_number.length;k++){
						var direction = get_direction(question_number[k]);
						var startpos = get_startpos(question_number[k],direction);
						console.log("q = " + question_number[k]);
						console.log(direction);
						console.log(startpos);
	
						if(direction == "horizontal" && startpos[0] == i && startpos[1] == j){
							starting_number += question_number[k] + ",";
						}
						else if(direction == "vertical" && startpos[0] == j && startpos[1] == i){
							starting_number += question_number[k] + ",";
						}              

					}

					if(starting_number != ""){
						question_number_span = '<span class="question_number">'+starting_number.replace(/(^,)|(,$)/g, "")+'</span>';   
					}

					$(row).append('<td>'+question_number_span+'<div class="square letter" data-number="'+this+'" contenteditable="true"></div></td>'); 
				}
			});
			$("#puzzle").append(row);
		});

		//Draw hints
		var vertical_hints = $('<div id="vertical_hints"></div>');
		var horizontal_hints = $('<div id="horizontal_hints"></div>');
		$.each(clues,function(index){

				var direction = get_direction(index+1);

				if(direction == "horizontal"){
				$(horizontal_hints).append('<div class="hint"><b>'+(index+1)+'</b>.-'+clues[index]+'</hint>');
				}
				else if(direction == "vertical"){
				$(vertical_hints).append('<div class="hint"><b>'+(index+1)+'</b>.-'+clues[index]+'</hint>');
				}
				});
		$("#vertical_hints_container").append(vertical_hints);
		$("#horizontal_hints_container").append(horizontal_hints);

		$(".letter").keyup(function(){
				var this_text = $(this).text();
				if(this_text.length > 1){
				$(this).text(this_text.slice(0,1));
				}
				});

		$(".letter").click(function(){
				document.execCommand('selectAll',false,null);

				$(".letter").removeClass("active");
				$(this).addClass("active");

				$(".hint").css("text-shadow","0 0 0 initial");

				var question_numbers = String($(this).data("number")).split(",");

				$.each(question_numbers,function(){
					$("#hints .hint:nth-child("+this+")").css("text-shadow","0 0 0 red");
					});
				});

		$("#solve").click(function(){
				if(!$(".letter.active").length)
				return;
				var question_numbers = String($(".letter.active").data("number")).split(",");
				$.each(question_numbers,function(){
					fillAnswer(this);
					});
				});

		$("#clear_all").click(function(){
				if(!$(".letter.active").length)
				return;
				var question_numbers = String($(".letter.active").data("number")).split(",");
				$.each(question_numbers,function(){
					clearAnswer(this);
					});
				});

		$("#check").click(function(){
				$("#puzzle td div").css("text-shadow","0 0 0 initial");
				for(var i = 0;i < answers.length;i++){
				checkAnswer(i+1);
				}    
				});

		$("#clue").click(function(){
				if(!$(".letter.active").length)
				return;
				var question_numbers = String($(".letter.active").data("number")).split(",");
				showClue(question_numbers[0],$(".letter.active").parent().index(),$(".letter.active").parent().parent().index());
				});

		function get_direction(question_number){
			for(var i=0;i < grid.length;i++){
				for(var j=0;j < grid[i].length;j++){
					if(String(grid[i][j]).indexOf(question_number) != -1){            
						if(((i < grid.length - 1) && grid[i+1][j] == question_number) || ((i > 0) && grid[i-1][j] == question_number)){
							return "vertical";
						}

						if(((j < grid[i].length - 1) && grid[i][j+1] == question_number) || ((j > 0) && grid[i][j-1] == question_number)){
							return "horizontal";
						}
					}
				}
			}
		}

		function get_startpos(question_number,direction){
			if(direction == "horizontal"){
				for(var i=0;i < grid.length;i++){
					for(var j=0;j < grid[i].length;j++){
						var nums = String(grid[i][j]).split(",");
						for (var k = 0; k < nums.length; k++){
							if(nums[k] == question_number){            
								return [i,j];
							}
						}
					}
				}
			}

			else if(direction == "vertical"){
				for(var i=0;i < grid.length;i++){
					for(var j=0;j < grid[i].length;j++){
						var nums = String(grid[j][i]).split(",");
						for (var k = 0; k < nums.length; k++){
							if(nums[k] == question_number){            
								return [i,j];
							}
						} 
					}
				}
			}
		}

		function fillAnswer(question_number){
			$("#puzzle td div").css("text-shadow","0 0 0 initial");

			var question_answer = answers[question_number-1];
			var direction = get_direction(question_number);
			var startpos = get_startpos(question_number,direction);
			var answer_letters = question_answer.split("");

			if(direction == "horizontal"){
				for(var i = 0; i < answer_letters.length; i++){
					$("#puzzle tr:nth-child("+(startpos[0]+1)+") td:nth-child("+(startpos[1]+1+i)+") div").text(answer_letters[i]);
				}

			}
			else if(direction == "vertical"){
				for(var i = 0; i < answer_letters.length; i++){
					$("#puzzle tr:nth-child("+(startpos[1]+1+i)+") td:nth-child("+(startpos[0]+1)+") div").text(answer_letters[i]);
				}

			}
		}

		function clearAnswer(question_number){
			$("#puzzle td div").css("text-shadow","0 0 0 initial");

			var question_answer = answers[question_number-1];
			var direction = get_direction(question_number);
			var startpos = get_startpos(question_number,direction);
			var answer_letters = question_answer.split("");

			if(direction == "horizontal"){
				for(var i = 0; i < answer_letters.length; i++){
					$("#puzzle tr:nth-child("+(startpos[0]+1)+") td:nth-child("+(startpos[1]+1+i)+") div").text('');
				}

			}
			else if(direction == "vertical"){
				for(var i = 0; i < answer_letters.length; i++){
					$("#puzzle tr:nth-child("+(startpos[1]+1+i)+") td:nth-child("+(startpos[0]+1)+") div").text('');
				}

			}
		}

		function checkAnswer(question_number){
			var question_answer = answers[question_number-1];
			var direction = get_direction(question_number);
			var startpos = get_startpos(question_number,direction);
			var answer_letters = question_answer.split("");

			if(direction == "horizontal"){
				for(var i = 0; i < answer_letters.length; i++){
					if($("#puzzle tr:nth-child("+(startpos[0]+1)+") td:nth-child("+(startpos[1]+1+i)+") div").text() != question_answer[i] && $("#puzzle tr:nth-child("+(startpos[0]+1)+") td:nth-child("+(startpos[1]+1+i)+") div").text() != ""){
						$("#puzzle tr:nth-child("+(startpos[0]+1)+") td:nth-child("+(startpos[1]+1+i)+") div").css("text-shadow","0 0 0 red");
					}
				}

			}
			else if(direction == "vertical"){
				for(var i = 0; i < answer_letters.length; i++){
					if($("#puzzle tr:nth-child("+(startpos[1]+1+i)+") td:nth-child("+(startpos[0]+1)+") div").text() != question_answer[i] && $("#puzzle tr:nth-child("+(startpos[1]+1+i)+") td:nth-child("+(startpos[0]+1)+") div").text() != ""){
						$("#puzzle tr:nth-child("+(startpos[1]+1+i)+") td:nth-child("+(startpos[0]+1)+") div").css("text-shadow","0 0 0 red");
					}
				}

			}
		}

		function showClue(question_number,i,j){
			var question_answer = answers[question_number-1];
			var direction = get_direction(question_number);
			var startpos = get_startpos(question_number,direction);
			var answer_letters = question_answer.split("");

			if(direction == "horizontal"){
				$("#puzzle tr:nth-child("+(j+1)+") td:nth-child("+(i+1)+") div").text(answer_letters[i - startpos[1]]).css("text-shadow","0 0 0 initial");
			}
			else if(direction == "vertical"){
				$("#puzzle tr:nth-child("+(j+1)+") td:nth-child("+(i+1)+") div").text(answer_letters[j - startpos[1]]).css("text-shadow","0 0 0 initial");
			}
		}

}); 
</script>


</head>

<body>
<div id="puzzle_container">
<table id="puzzle">
</table>
</div>

<div id="hints_container">
<h3>Vertical</h3>
<div id="vertical_hints_container"></div>
<h3>Horizontal</h3>
<div id="horizontal_hints_container"></div>
</div>

<div id="buttons_container">
<button id="clear_all">Clear All</button>
<button id="check">Check</button>
<button id="solve">Solve</button>
<button id="clue">Clue</button>
</div>


</body>

</html>


